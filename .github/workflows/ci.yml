name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  release:
    types: [published]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Pre-build shared dependencies for all matrix jobs
  prebuild-deps:
    name: Pre-build Shared Dependencies
    runs-on: ubuntu-latest
    outputs:
      cache-key: ${{ steps.cache-keys.outputs.deps-key }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Nix
      uses: DeterminateSystems/nix-installer-action@main

    - name: Configure Cachix
      uses: cachix/cachix-action@v15
      with:
        name: nanna-coder
        authToken: '${{ secrets.CACHIX_AUTH }}'
        pushFilter: "(-source$|nixpkgs\\.tar\\.gz$)"
        skipPush: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}

    - name: Generate cache keys
      id: cache-keys
      run: |
        FLAKE_HASH=$(sha256sum flake.lock | cut -d' ' -f1 | head -c 16)
        CARGO_HASH=$(sha256sum Cargo.lock | cut -d' ' -f1 | head -c 16)
        DEPS_KEY="cachix-v1-deps-${FLAKE_HASH}-${CARGO_HASH}"
        echo "deps-key=${DEPS_KEY}" >> $GITHUB_OUTPUT
        echo "üîë Dependency cache key: ${DEPS_KEY}"

    - name: Pre-build Rust toolchain and dependencies
      run: |
        echo "üî® Pre-building shared dependencies for all matrix jobs..."
        START_TIME=$(date +%s)

        # Build just the dependencies (cargoArtifacts)
        echo "üì¶ Building Cargo dependencies..."
        nix build .#packages.x86_64-linux.nanna-coder.cargoArtifacts --print-build-logs --no-link || {
          echo "‚ö†Ô∏è Building via cargoArtifacts failed, using develop shell instead"
          nix develop --command cargo fetch
          nix develop --command cargo build --workspace --lib --release
        }

        END_TIME=$(date +%s)
        echo "‚úÖ Dependencies pre-built in $((END_TIME - START_TIME))s"

    - name: Report cache status
      run: |
        echo "## üì¶ Dependency Pre-build Report" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "üî® **Status:** Dependencies built and pushed to Cachix" >> $GITHUB_STEP_SUMMARY
        echo "üîë **Cache Key:** \`${{ steps.cache-keys.outputs.deps-key }}\`" >> $GITHUB_STEP_SUMMARY
        echo "üì¶ **Strategy:** Cachix binary cache (unlimited storage)" >> $GITHUB_STEP_SUMMARY

  # Parallel job matrix for comprehensive testing
  test-matrix:
    needs: prebuild-deps
    name: ${{ matrix.test-type }} (${{ matrix.rust }}, ${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]
        rust: [stable, beta]
        test-type: [unit, integration, lint, security]
        include:
          # Add Windows for stable Rust only
          - os: windows-latest
            rust: stable
            test-type: unit
          - os: windows-latest
            rust: stable
            test-type: lint
          # Add nightly Rust for Linux only with specific test types
          - os: ubuntu-latest
            rust: nightly
            test-type: unit
        exclude:
          # Skip integration tests on macOS (no container support)
          - os: macos-latest
            test-type: integration
          # Skip security tests on macOS and Windows (Linux only)
          - os: macos-latest
            test-type: security
          - os: windows-latest
            test-type: security

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Nix
      if: runner.os != 'Windows'
      uses: DeterminateSystems/nix-installer-action@main

    - name: Record job start time
      if: runner.os != 'Windows'
      id: job-start
      run: echo "start_time=$(date +%s)" >> $GITHUB_OUTPUT

    - name: Configure Cachix
      if: runner.os != 'Windows'
      uses: cachix/cachix-action@v15
      with:
        name: nanna-coder
        authToken: '${{ secrets.CACHIX_AUTH }}'
        pushFilter: "(-source$|nixpkgs\\.tar\\.gz$)"
        skipPush: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}

    - name: Cachix Status
      if: runner.os != 'Windows'
      id: cache-status
      run: |
        echo "üìä === Cachix Binary Cache Status (with prebuild-deps optimization) ==="
        echo "üîë Shared Dependency Key: ${{ needs.prebuild-deps.outputs.cache-key }}"
        echo "üîë Cache: nanna-coder.cachix.org"
        echo "üì¶ Cache Action: cachix/cachix-action@v15"
        echo "üîí Authentication: ${{ secrets.CACHIX_AUTH != '' && 'Configured' || 'Missing' }}"
        echo "üïê Cache restore time: $(($(date +%s) - ${{ steps.job-start.outputs.start_time }}))s"

        if [ "${{ github.event_name }}" = "pull_request" ] && [ "${{ github.event.pull_request.head.repo.fork }}" = "true" ]; then
          echo "üîê Fork PR: Read-only cache access"
        else
          echo "‚úÖ Push enabled: Artifacts will be cached"
        fi

        echo "üíæ Cache storage: Unlimited (Cachix)"
        echo "‚ö° Strategy: Cachix binary cache + prebuild-deps optimization"
        echo "üöÄ Build performance: OPTIMIZED (leveraging shared dependencies)"

    - name: Setup Rust toolchain (Windows)
      if: runner.os == 'Windows'
      uses: dtolnay/rust-toolchain@master
      with:
        toolchain: ${{ matrix.rust }}
        components: rustfmt, clippy

    - name: Setup Rust toolchain (macOS)
      if: runner.os == 'macOS'
      uses: dtolnay/rust-toolchain@master
      with:
        toolchain: ${{ matrix.rust }}
        components: rustfmt, clippy

    - name: Install additional tools (non-Nix)
      if: runner.os != 'Linux'
      shell: bash
      run: |
        cargo install cargo-nextest cargo-audit cargo-deny
        if [ "${{ matrix.test-type }}" = "security" ]; then
          cargo install cargo-tarpaulin
        fi

    - name: Optimize CI cache settings (Nix)
      if: runner.os == 'Linux'
      run: nix run .#ci-cache-optimize

    - name: Pre-build test containers (Integration tests only)
      if: matrix.test-type == 'integration' && runner.os == 'Linux'
      run: |
        echo "üîÑ Building test containers for caching..."
        nix build .#ollamaImage --print-build-logs

        echo "üì¶ Loading test containers into podman (nix2container format)..."
        # nix2container creates JSON manifests, not tar archives - use custom loader
        nix run .#load-ollama-image

        echo "‚úÖ Test containers ready for integration tests"

    - name: Run unit tests
      if: matrix.test-type == 'unit'
      shell: bash
      run: |
        START_TIME=$(date +%s)
        if [ "${{ runner.os }}" = "Linux" ]; then
          nix develop --command cargo nextest run --workspace --lib
        else
          cargo nextest run --workspace --lib
        fi
        END_TIME=$(date +%s)
        echo "‚è±Ô∏è  Unit tests completed in $((END_TIME - START_TIME))s"

    - name: Run integration tests
      if: matrix.test-type == 'integration'
      shell: bash
      run: |
        if [ "${{ runner.os }}" = "Linux" ]; then
          nix run .#container-test
        else
          echo "‚ö†Ô∏è Integration tests skipped on ${{ runner.os }} (no container support)"
        fi

    - name: Run lint checks
      if: matrix.test-type == 'lint'
      shell: bash
      run: |
        if [ "${{ runner.os }}" = "Linux" ]; then
          nix develop --command cargo clippy --workspace --all-targets -- -D warnings
          nix develop --command cargo fmt --all -- --check
        else
          cargo clippy --workspace --all-targets -- -D warnings
          cargo fmt --all -- --check
        fi

    - name: Run security checks
      if: matrix.test-type == 'security'
      shell: bash
      run: |
        if [ "${{ runner.os }}" = "Linux" ]; then
          nix develop --command cargo audit
          nix develop --command cargo deny check
          nix develop --command cargo tarpaulin --skip-clean --ignore-tests --out Lcov --output-dir . --timeout 300
        else
          echo "‚ö†Ô∏è Security checks skipped on ${{ runner.os }}"
        fi

    - name: Upload coverage reports
      if: matrix.test-type == 'security' && runner.os == 'Linux'
      uses: codecov/codecov-action@v3
      with:
        file: lcov.info
        fail_ci_if_error: false
        flags: ${{ matrix.rust }}

    - name: Cache analytics and performance metrics
      if: always() && runner.os == 'Linux'
      run: |
        echo "## üìä Cache Performance Report - ${{ matrix.test-type }} (${{ matrix.rust }}, ${{ matrix.os }})" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "üîë **Shared Dependency Key:** \`${{ needs.prebuild-deps.outputs.cache-key }}\`" >> $GITHUB_STEP_SUMMARY
        echo "üì¶ **Cache Backend:** Cachix (nanna-coder.cachix.org)" >> $GITHUB_STEP_SUMMARY
        echo "‚ö° **Strategy:** Prebuild-deps + Cachix binary cache" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        nix run .#cache-analytics >> $GITHUB_STEP_SUMMARY 2>&1 || echo "Unable to run detailed analytics" >> $GITHUB_STEP_SUMMARY

  # Parallel performance benchmarking (temporarily disabled - no benchmarks configured)
  benchmark:
    name: Performance Benchmarks
    runs-on: ubuntu-latest
    if: false  # Temporarily disabled until benchmarks are properly configured

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Nix
      uses: DeterminateSystems/nix-installer-action@main

    - name: Configure Cachix
      uses: cachix/cachix-action@v15
      with:
        name: nanna-coder
        authToken: '${{ secrets.CACHIX_AUTH }}'
        pushFilter: "(-source$|nixpkgs\\.tar\\.gz$)"

    - name: Run benchmarks
      run: |
        echo "üèÉ Running performance benchmarks..."
        nix develop --command cargo bench --workspace

    - name: Store benchmark results
      uses: benchmark-action/github-action-benchmark@v1
      with:
        tool: 'cargo'
        output-file-path: target/criterion/reports/benchmark.json
        github-token: ${{ secrets.GITHUB_TOKEN }}
        auto-push: true
        comment-on-alert: true
        alert-threshold: '200%'

  # Parallel build matrix for multiple targets
  build-matrix:
    name: Build ${{ matrix.target }}
    runs-on: ${{ matrix.runner }}
    needs: test-matrix
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: x86_64-linux
            runner: ubuntu-latest
            cross: false
          - target: aarch64-linux
            runner: ubuntu-latest
            cross: true
          - target: x86_64-darwin
            runner: macos-latest
            cross: false
          - target: aarch64-darwin
            runner: macos-latest
            cross: true

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Nix (Linux)
      if: runner.os == 'Linux'
      uses: DeterminateSystems/nix-installer-action@main

    - name: Configure Cachix (Linux)
      if: runner.os == 'Linux'
      uses: cachix/cachix-action@v15
      with:
        name: nanna-coder
        authToken: '${{ secrets.CACHIX_AUTH }}'
        pushFilter: "(-source$|nixpkgs\\.tar\\.gz$)"

    - name: Setup Rust toolchain (macOS)
      if: runner.os == 'macOS'
      uses: dtolnay/rust-toolchain@master
      with:
        toolchain: stable

    - name: Setup cross-compilation (aarch64)
      if: matrix.cross
      shell: bash
      run: |
        if [ "${{ runner.os }}" = "Linux" ]; then
          # Use Nix for cross-compilation on Linux
          echo "Setting up Nix cross-compilation for ${{ matrix.target }}"
        else
          # Use cargo for cross-compilation on macOS
          rustup target add aarch64-apple-darwin
        fi

    - name: Build workspace (Nix)
      if: runner.os == 'Linux'
      run: |
        if [ "${{ matrix.cross }}" = "true" ]; then
          # Try cross-compilation, fallback to native
          nix build .#packages.${{ matrix.target }}.nanna-coder || nix build .#nanna-coder
        else
          nix build .#nanna-coder
        fi

    - name: Build workspace (Cargo)
      if: runner.os == 'macOS'
      run: |
        if [ "${{ matrix.cross }}" = "true" ]; then
          cargo build --release --target aarch64-apple-darwin
        else
          cargo build --release
        fi

    - name: Prepare artifacts (Nix)
      if: runner.os == 'Linux'
      run: |
        mkdir -p artifacts
        if [ -d "result/bin" ]; then
          cp result/bin/* artifacts/ || true
        fi
        if [ -f "result" ]; then
          cp result artifacts/nanna-coder-${{ matrix.target }} || true
        fi

    - name: Prepare artifacts (Cargo)
      if: runner.os == 'macOS'
      run: |
        mkdir -p artifacts
        if [ "${{ matrix.cross }}" = "true" ]; then
          cp target/aarch64-apple-darwin/release/harness artifacts/harness-${{ matrix.target }} || true
        else
          cp target/release/harness artifacts/harness-${{ matrix.target }} || true
        fi

    - name: Upload binary artifacts
      uses: actions/upload-artifact@v4
      with:
        name: nanna-coder-${{ matrix.target }}
        path: artifacts/*
        if-no-files-found: warn

  # Parallel container builds with multi-model support
  build-containers:
    name: Build ${{ matrix.image }} (${{ matrix.arch }})
    runs-on: ubuntu-latest
    needs: [test-matrix, prebuild-deps]
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        arch: [x86_64]  # Disabled aarch64 - cross-compilation not working
        image: [harness, ollama]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Nix
      uses: DeterminateSystems/nix-installer-action@main

    - name: Configure Cachix
      uses: cachix/cachix-action@v15
      with:
        name: nanna-coder
        authToken: '${{ secrets.CACHIX_AUTH }}'
        pushFilter: "(-source$|nixpkgs\\.tar\\.gz$)"
        skipPush: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}

    - name: Set up QEMU for cross-platform builds
      if: matrix.arch == 'aarch64'
      uses: docker/setup-qemu-action@v3
      with:
        platforms: arm64

    - name: Log in to Container Registry
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Container cache status
      run: |
        echo "üìä === Container Build Cache Status ==="
        echo "üîë Shared Dependency Key: ${{ needs.prebuild-deps.outputs.cache-key }}"
        echo "üê≥ Building: ${{ matrix.image }} for ${{ matrix.arch }}"
        echo "üì¶ Cache Backend: Cachix (nanna-coder.cachix.org)"
        echo "‚ö° Strategy: Leveraging prebuild-deps + Cachix binary cache"

    - name: Build container image
      run: |
        echo "üê≥ Building ${{ matrix.image }} for ${{ matrix.arch }}"
        START_TIME=$(date +%s)

        case "${{ matrix.image }}" in
          "harness")
            if [ "${{ matrix.arch }}" = "x86_64" ]; then
              nix build .#harnessImage --print-build-logs
            else
              nix build .#packages.aarch64-linux.harnessImage --print-build-logs || nix build .#harnessImage --print-build-logs
            fi
            ;;
          "ollama")
            if [ "${{ matrix.arch }}" = "x86_64" ]; then
              nix build .#ollamaImage --print-build-logs
            else
              nix build .#packages.aarch64-linux.ollamaImage --print-build-logs || nix build .#ollamaImage --print-build-logs
            fi
            ;;
          "qwen3-container")
            nix build .#qwen3-container --print-build-logs
            ;;
          "llama3-container")
            nix build .#llama3-container --print-build-logs
            ;;
        esac

        END_TIME=$(date +%s)
        BUILD_TIME=$((END_TIME - START_TIME))
        echo "‚úÖ Container built in ${BUILD_TIME}s"
        echo "build_time=${BUILD_TIME}" >> $GITHUB_ENV

    - name: Load and tag container image
      shell: bash
      run: |
        echo "üì¶ Loading ${{ matrix.image }} container using nix2container's copyToDockerDaemon"

        # Determine image name and nix attribute based on matrix.image
        case "${{ matrix.image }}" in
          "harness")
            IMAGE_NAME="nanna-coder-harness"
            REGISTRY_NAME="harness"
            NIX_ATTR="harnessImage"
            ;;
          "ollama")
            IMAGE_NAME="nanna-coder-ollama"
            REGISTRY_NAME="ollama"
            NIX_ATTR="ollamaImage"
            ;;
          "qwen3-container")
            IMAGE_NAME="nanna-coder-ollama-qwen3"
            REGISTRY_NAME="ollama-qwen3"
            NIX_ATTR="qwen3-container"
            ;;
          "llama3-container")
            IMAGE_NAME="nanna-coder-ollama-llama3"
            REGISTRY_NAME="ollama-llama3"
            NIX_ATTR="llama3-container"
            ;;
        esac

        # Use nix2container's built-in copyToDockerDaemon helper
        # This uses skopeo with the nix: transport that understands nix2container JSON format
        echo "Loading image using: nix run .#${NIX_ATTR}.copyToDockerDaemon"
        nix run .#${NIX_ATTR}.copyToDockerDaemon

        # Tag for registry (convert repository name to lowercase for Docker compatibility)
        REPO_LOWERCASE=$(echo "${{ env.IMAGE_NAME }}" | tr '[:upper:]' '[:lower:]')
        docker tag ${IMAGE_NAME}:latest ${{ env.REGISTRY }}/${REPO_LOWERCASE}/${REGISTRY_NAME}:${{ github.sha }}
        docker tag ${IMAGE_NAME}:latest ${{ env.REGISTRY }}/${REPO_LOWERCASE}/${REGISTRY_NAME}:latest

    - name: Push container images
      if: github.event_name != 'pull_request'
      run: |
        echo "üöÄ Pushing ${{ matrix.image }} images"

        # Determine registry name
        case "${{ matrix.image }}" in
          "harness")
            REGISTRY_NAME="harness"
            ;;
          "ollama")
            REGISTRY_NAME="ollama"
            ;;
          "qwen3-container")
            REGISTRY_NAME="ollama-qwen3"
            ;;
          "llama3-container")
            REGISTRY_NAME="ollama-llama3"
            ;;
        esac

        # Convert repository name to lowercase for Docker compatibility
        REPO_LOWERCASE=$(echo "${{ env.IMAGE_NAME }}" | tr '[:upper:]' '[:lower:]')
        docker push ${{ env.REGISTRY }}/${REPO_LOWERCASE}/${REGISTRY_NAME}:${{ github.sha }}
        docker push ${{ env.REGISTRY }}/${REPO_LOWERCASE}/${REGISTRY_NAME}:latest

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: build-containers
    if: github.event_name != 'pull_request'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set lowercase repository name
      id: repo
      run: echo "lowercase=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ steps.repo.outputs.lowercase }}/harness:latest
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-results.sarif'

  cache-maintenance:
    name: Cache Maintenance
    runs-on: ubuntu-latest
    needs: [test-matrix, build-matrix, build-containers]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Nix
      uses: DeterminateSystems/nix-installer-action@main

    - name: Configure Cachix
      uses: cachix/cachix-action@v15
      with:
        name: nanna-coder
        authToken: '${{ secrets.CACHIX_AUTH }}'
        pushFilter: "(-source$|nixpkgs\\.tar\\.gz$)"

    - name: Note cache strategy
      run: |
        echo "üì¶ Using Cachix for binary caching"
        echo "üîÑ Cache: nanna-coder.cachix.org"
        echo "‚úÖ Unlimited storage with Cachix"

    - name: Cache analytics and reporting
      run: |
        echo "## üìä Binary Cache Performance Report" >> $GITHUB_STEP_SUMMARY
        echo "Generated: $(date)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        nix run .#cache-analytics >> $GITHUB_STEP_SUMMARY

  # Parallel multi-platform release builds
  release:
    name: Create Release (${{ matrix.target }})
    runs-on: ${{ matrix.runner }}
    needs: [test-matrix, build-matrix, build-containers]
    if: github.event_name == 'release'
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: x86_64-linux
            runner: ubuntu-latest
          - target: aarch64-linux
            runner: ubuntu-latest
          - target: x86_64-darwin
            runner: macos-latest
          - target: aarch64-darwin
            runner: macos-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Nix
      uses: DeterminateSystems/nix-installer-action@main

    - name: Configure Cachix
      uses: cachix/cachix-action@v15
      with:
        name: nanna-coder
        authToken: '${{ secrets.CACHIX_AUTH }}'
        pushFilter: "(-source$|nixpkgs\\.tar\\.gz$)"

    - name: Build release artifacts
      run: |
        nix build .#packages.x86_64-linux.nanna-coder
        cp result/bin/harness harness-x86_64-linux

        nix build .#packages.aarch64-linux.nanna-coder
        cp result/bin/harness harness-aarch64-linux

    - name: Upload release artifacts
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url }}
        asset_path: ./harness-x86_64-linux
        asset_name: harness-x86_64-linux
        asset_content_type: application/octet-stream

    - name: Upload ARM64 release artifacts
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url }}
        asset_path: ./harness-aarch64-linux
        asset_name: harness-aarch64-linux
        asset_content_type: application/octet-stream

  # CI summary and status aggregation
  ci-summary:
    name: CI Summary
    runs-on: ubuntu-latest
    needs: [test-matrix, build-matrix, build-containers]  # benchmark: temporarily disabled
    if: always()

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Generate CI Summary
      run: |
        echo "## üéØ CI/CD Pipeline Summary" >> $GITHUB_STEP_SUMMARY
        echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "**Event:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        echo "### üìä Job Status Overview" >> $GITHUB_STEP_SUMMARY
        echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| Test Matrix | ${{ needs.test-matrix.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Build Matrix | ${{ needs.build-matrix.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Container Builds | ${{ needs.build-containers.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Benchmarks | disabled |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        echo "### üèóÔ∏è Build Artifacts" >> $GITHUB_STEP_SUMMARY
        echo "- Multi-platform binaries (x86_64/aarch64 Linux, macOS)" >> $GITHUB_STEP_SUMMARY
        echo "- Container images (harness, ollama, model containers)" >> $GITHUB_STEP_SUMMARY
        echo "- Performance benchmarks" >> $GITHUB_STEP_SUMMARY
        echo "- Code coverage reports" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        # Determine overall status
        OVERALL_STATUS="‚úÖ SUCCESS"
        if [[ "${{ needs.test-matrix.result }}" == "failure" || "${{ needs.build-matrix.result }}" == "failure" || "${{ needs.build-containers.result }}" == "failure" ]]; then
          OVERALL_STATUS="‚ùå FAILURE"
        elif [[ "${{ needs.test-matrix.result }}" == "cancelled" || "${{ needs.build-matrix.result }}" == "cancelled" || "${{ needs.build-containers.result }}" == "cancelled" ]]; then
          OVERALL_STATUS="‚ö†Ô∏è CANCELLED"
        fi

        echo "### üéØ Overall Status: $OVERALL_STATUS" >> $GITHUB_STEP_SUMMARY

    - name: Check for failures
      if: needs.test-matrix.result == 'failure' || needs.build-matrix.result == 'failure' || needs.build-containers.result == 'failure'
      run: |
        echo "‚ùå CI pipeline failed. Check the failed jobs above for details."
        exit 1